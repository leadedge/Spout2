//
//
//			spoutDirectX9.cpp
//
//		Functions to manage DirectX9 texture sharing
//
// ====================================================================================
//		Revisions :
//
//		09.10.20	- separated from SpoutDirectX class
//		23.01.21	- Create DX9 examples
//		23.01.21	- Change d3dpp.EnableAutoDepthStencil to TRUE so examples work
//		14-10-25	- CreateDX9device - Set the backbuffer size to that of the window if passed in
//
// ====================================================================================
/*

	Copyright (c) 2014-2022. Lynn Jarvis. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, 
	are permitted provided that the following conditions are met:

		1. Redistributions of source code must retain the above copyright notice, 
		   this list of conditions and the following disclaimer.

		2. Redistributions in binary form must reproduce the above copyright notice, 
		   this list of conditions and the following disclaimer in the documentation 
		   and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"	AND ANY 
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
	OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE	ARE DISCLAIMED. 
	IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

#include "SpoutDirectX9.h"

spoutDirectX9::spoutDirectX9() {

	m_pD3D = nullptr;
	m_pDevice = nullptr;
}

spoutDirectX9::~spoutDirectX9() {

}


// ================ DX9 ==================

// Initialize and prepare DirectX 9
bool spoutDirectX9::OpenDirectX9(HWND hWnd)
{
	HWND fgWnd = NULL;
	char fgwndName[MAX_PATH]{}; // Ensure null terminated

	SpoutLogNotice("spoutDirectX9::OpenDirectX9 - hWnd = 0x%.7X", PtrToUint(hWnd) );

	// Already initialized ?
	if (m_pD3D) {
		SpoutLogNotice("    Device already initialized");
		return true;
	}

	// Create a IDirect3D9Ex object if not already created
	m_pD3D = CreateDX9object();

	if (!m_pD3D) {
		SpoutLogWarning("    Could not create DX9 object");
		return false;
	}

	// Create DX9 device
	if (!m_pDevice) {
		m_pDevice = CreateDX9device(m_pD3D, hWnd);
	}

	if (!m_pDevice) {
		SpoutLogWarning("    Could not create DX9 device");
		return false;
	}

	// Problem for FFGL plugins - might be a problem for other FFGL hosts or applications.
	// DirectX 9 device initialization creates black areas and the host window has to be redrawn.
	// But this causes a crash for a sender in Magic when the render window size is changed.
	//   o Not a problem for DirectX 11.
	//   o Not needed in Isadora.
	//   o Needed for Resolume.
	// For now, limit this to Resolume only.
	// TODO : re-test this old issue
	fgWnd = GetForegroundWindow();
	if (fgWnd) {
		// SMTO_ABORTIFHUNG : The function returns without waiting for the time-out
		// period to elapse if the receiving thread appears to not respond or "hangs."
		if (SendMessageTimeoutA(fgWnd, WM_GETTEXT, MAX_PATH, (LPARAM)fgwndName, SMTO_ABORTIFHUNG, 128, NULL) != 0) {
			// Returns the full path - get just the window name
			spoututils::GetName(fgwndName); // avoid shlwapi
			// PathStripPathA(fgwndName);
			if (fgwndName[0]) {
				if (strstr(fgwndName, "Resolume") != NULL // Is resolume in the window title ?
					&& strstr(fgwndName, "magic") == NULL) { // Make sure it is not a user named magic project.
						// DirectX device initialization needs the window to be redrawn (creates black areas)
						// 03.05.15 - user observation that UpDateWindow does not work and Resolume GUI is still corrupted
						// 28.08.15 - user observation of a crash with Windows 10 
						// try RedrawWindow again (with InvalidateRect as well) - confirmed working with Win 7 32bit
						// https://msdn.microsoft.com/en-us/library/windows/desktop/dd145213%28v=vs.85%29.aspx
						// The WM_PAINT message is generated by the system and should not be sent by an application.					
						// SendMessage(fgWnd, WM_PAINT, NULL, NULL ); // causes problems
					InvalidateRect(fgWnd, NULL, false); // make sure
					RedrawWindow(hWnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASENOW | RDW_INTERNALPAINT);
				}
			}
		}
	}

	return true;
}

// Create a DX9 object
IDirect3D9Ex* spoutDirectX9::CreateDX9object()
{
	IDirect3D9Ex* pD3D;

	HRESULT res = Direct3DCreate9Ex(D3D_SDK_VERSION, &pD3D);
	if (FAILED(res)) return NULL;

	return pD3D;
}

// Create a DX9 device
IDirect3DDevice9Ex* spoutDirectX9::CreateDX9device(IDirect3D9Ex* pD3D, HWND hWnd, unsigned int AdapterIndex)
{
	IDirect3DDevice9Ex* pDevice;
    D3DPRESENT_PARAMETERS d3dpp;
	D3DCAPS9 d3dCaps;

	SpoutLogNotice("spoutDirectX::CreateDX9device - adapter = %u, hWnd = 0x%.7X", AdapterIndex, PtrToUint(hWnd) );

    ZeroMemory(&d3dpp, sizeof(d3dpp));
    d3dpp.Windowed		= true;						// windowed and not full screen
    d3dpp.SwapEffect	= D3DSWAPEFFECT_DISCARD;	// discard old frames
    d3dpp.hDeviceWindow	= hWnd;						// set the window to be used by D3D

	// Defult backbuffer is 1920x1080 if no window handle
	// Set a dummy resolution - we don't render anything
	UINT BackBufferWidth = 1920;
	UINT BackBufferHeight = 1080;

	// Set the backbuffer size to that of the window if passed in
	if (hWnd) {
		RECT rect{};
		GetWindowRect(hWnd, &rect);
		BackBufferWidth = (UINT)(rect.right - rect.left);
		BackBufferHeight = (UINT)(rect.bottom - rect.top);
	}
	// D3DFMT_UNKNOWN can be specified for the BackBufferFormat while in windowed mode. 
	// This tells the runtime to use the current display-mode format and eliminates
	// the need to call GetDisplayMode. 
	d3dpp.BackBufferFormat		 = D3DFMT_UNKNOWN;

    d3dpp.BackBufferWidth		 = BackBufferWidth;
    d3dpp.BackBufferHeight		 = BackBufferHeight;
	d3dpp.EnableAutoDepthStencil = TRUE;
	d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
	d3dpp.BackBufferCount		 = 1;

	// Test for hardware vertex processing capability and set up as needed
	// D3DCREATE_MULTITHREADED required by interop spec
	if (FAILED(pD3D->GetDeviceCaps(AdapterIndex, D3DDEVTYPE_HAL, &d3dCaps))) {
		SpoutLogFatal("spoutDirectX9::CreateDX9device - GetDeviceCaps error");
		return NULL;
	}

	// | D3DCREATE_NOWINDOWCHANGES
	DWORD dwBehaviorFlags = D3DCREATE_PUREDEVICE | D3DCREATE_MULTITHREADED; 
	if ( d3dCaps.VertexProcessingCaps != 0 )
		dwBehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;
	else
		dwBehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	// Create a DirectX9 device - we use directx only for accessing the handle
	// Note : hwnd seems to have no effect - maybe because we do not render anything.
	// Note here that we are setting up for Windowed mode but it seems not to be affected
	// by fullscreen, probably because we are not rendering to it.
	HRESULT res = pD3D->CreateDeviceEx(	AdapterIndex,   // D3DADAPTER_DEFAULT
								D3DDEVTYPE_HAL, // Hardware rasterization. 
								hWnd,			// hFocusWindow (can be NULL)
								dwBehaviorFlags,
								&d3dpp,			// d3dpp.hDeviceWindow should be valid if hFocusWindow is NULL
								NULL,			// pFullscreenDisplayMode must be NULL for windowed mode
								&pDevice);
	
	if (FAILED(res)) {
		SpoutLogFatal("spoutDirectX9::CreateDX9device - CreateDeviceEx returned error %u (0x%.X)", LOWORD(res), LOWORD(res) );
		return NULL;
	}

	SpoutLogNotice("    device (0x%.7X)", PtrToUint(pDevice) );

	return pDevice;

} // end CreateDX9device

IDirect3D9Ex* spoutDirectX9::GetDX9object()
{
	return m_pD3D;
}

IDirect3DDevice9Ex* spoutDirectX9::GetDX9device()
{
	return m_pDevice;
}

void spoutDirectX9::SetDX9device(IDirect3DDevice9Ex* pDevice)
{
	// The Spout DX9 object is not used if the device is set externally
	if (m_pD3D) {
		m_pD3D->Release();
		// If set externally, the device is also released externally,
		// so it must not be released in this class.
		// The Spout DX9 device can be released here because
		// it will not be released again if m_pD3D is NULL
		if (m_pDevice)
			m_pDevice->Release();
		m_pD3D = nullptr;
		m_pDevice = nullptr;
	}

	SpoutLogNotice("spoutDirectX9::SetDX9device (0x%.7X)", PtrToUint(pDevice) );

	// Already initialized ?
	if (pDevice && m_pDevice == pDevice) {
		SpoutLogWarning("spoutDirectX9::SetDX9device -(0x%.7X) already initialized", PtrToUint(pDevice) );
	}

	// Set the Spout DX9 device to the application device
	m_pDevice = pDevice;

}

void spoutDirectX9::CloseDirectX9()
{
	SpoutLogNotice("spoutDirectX9::CloseDirectX9");

	if (m_pD3D) {
		// Release device before the object
		if (m_pDevice)
			m_pDevice->Release();
		m_pD3D->Release();
	}
	m_pDevice = nullptr;
	m_pD3D = nullptr;

}


// Create a shared DirectX9 texture
// by giving it a sharehandle variable - dxShareHandle
// For a SENDER : the sharehandle is NULL and a new texture is created
// For a RECEIVER : the sharehandle is valid and a handle to the existing shared texture is created
bool spoutDirectX9::CreateSharedDX9Texture(IDirect3DDevice9Ex* pDevice, unsigned int width, unsigned int height, D3DFORMAT format, LPDIRECT3DTEXTURE9 &dxTexture, HANDLE &dxShareHandle)
{
	if (!pDevice) {
		SpoutLogError("spoutDirectX9::CreateSharedDX9Texture - NULL DX9 device");
		return false;
	}

	if(dxTexture) dxTexture->Release();

	HRESULT res = pDevice->CreateTexture(width,
										 height,
										 1,
										 D3DUSAGE_RENDERTARGET, 
										 format, // default is D3DFMT_A8R8G8B8 - may be set externally
										 D3DPOOL_DEFAULT, // Required by interop spec
										 &dxTexture,
										 &dxShareHandle);	// local share handle to allow type casting for 64bit

	// USAGE may also be D3DUSAGE_DYNAMIC and pay attention to format and resolution!!!
	// USAGE, format and size for sender and receiver must all match
	if (FAILED(res)) {
		char tmp[256];
		sprintf_s(tmp, 256, "spoutDirectX9::CreateSharedDX9Texture error %d (0x%.X) - ", LOWORD(res), LOWORD(res) );
		switch (LOWORD(res)) {
			case ERROR_INVALID_PARAMETER:
				strcat_s(tmp, 256, "ERROR_INVALID_PARAMETER");
				break;
			case D3DERR_INVALIDCALL:
				strcat_s(tmp, 256, "D3DERR_INVALIDCALL");
				break;
			case D3DERR_OUTOFVIDEOMEMORY:
				strcat_s(tmp, 256, "D3DERR_OUTOFVIDEOMEMORY");
				break;
			case E_OUTOFMEMORY:
				strcat_s(tmp, 256, "E_OUTOFMEMORY");
				break;
			default :
				strcat_s(tmp, 256, "Unknown error");
				break;
		}
		SpoutLogFatal("%s", tmp);
		return false;
	}

	SpoutLogNotice("spoutDirectX9::CreateSharedDX9Texture %dx%d - format %d - handle 0x%.7X", width, height, (int)format, LOWORD(dxShareHandle) );


	return true;

} // end CreateSharedDX9Texture


bool spoutDirectX9::WriteDX9memory(IDirect3DDevice9Ex* pDevice, LPDIRECT3DSURFACE9 source_surface, LPDIRECT3DTEXTURE9 dxTexture)
{
	IDirect3DSurface9* texture_surface = nullptr;
	IDirect3DQuery9* pEventQuery = nullptr;
	HRESULT hr = 0;
	hr = dxTexture->GetSurfaceLevel(0, &texture_surface); // shared texture surface
	if (SUCCEEDED(hr)) {
		// UpdateSurface
		// https://msdn.microsoft.com/en-us/library/windows/desktop/bb205857%28v=vs.85%29.aspx
		//    The source surface must have been created with D3DPOOL_SYSTEMMEM.
		//    The destination surface must have been created with D3DPOOL_DEFAULT.
		//    Neither surface can be locked or holding an outstanding device context.
		hr = pDevice->UpdateSurface(source_surface, NULL, texture_surface, NULL);
		if (SUCCEEDED(hr)) {
			// It is necessary to flush the command queue 
			// or the data is not ready for the receiver to read.
			// Adapted from : https://msdn.microsoft.com/en-us/library/windows/desktop/bb172234%28v=vs.85%29.aspx
			// Also see : http://www.ogre3d.org/forums/viewtopic.php?f=5&t=50486
			pDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEventQuery);
			if (pEventQuery) {
				pEventQuery->Issue(D3DISSUE_END);
				while (S_FALSE == pEventQuery->GetData(NULL, 0, D3DGETDATA_FLUSH));
				pEventQuery->Release(); // Must be released or causes a leak and reference count increment
			}
			return true;
		}
	}

	SpoutLogError("spoutDirectX9::WriteDX9surface((0x%.7X), (0x%.7X), (0x%.7X) failed", PtrToUint(pDevice), PtrToUint(dxTexture), PtrToUint(source_surface) );

	return false;
} // end WriteDX9memory


//
// COPY FROM A GPU DX9 SURFACE TO THE SHARED DX9 TEXTURE
//
//    The source surface must have been created using the same device as the texture
//
bool spoutDirectX9::WriteDX9surface(IDirect3DDevice9Ex* pDevice, LPDIRECT3DSURFACE9 surface, LPDIRECT3DTEXTURE9 dxTexture)
{
	IDirect3DSurface9* texture_surface = nullptr;
	HRESULT hr = dxTexture->GetSurfaceLevel(0, &texture_surface); // destination texture surface
	if (SUCCEEDED(hr)) {
		// StretchRect is a GPU copy
		hr = pDevice->StretchRect(surface, NULL, texture_surface, NULL, D3DTEXF_NONE);
		if(SUCCEEDED(hr)) {
			// It is necessary to flush the command queue
			// or the data is not ready for the receiver to read.
			// Adapted from : https://msdn.microsoft.com/en-us/library/windows/desktop/bb172234%28v=vs.85%29.aspx
			// Also see : http://www.ogre3d.org/forums/viewtopic.php?f=5&t=50486
			IDirect3DQuery9* pEventQuery = nullptr;
			pDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEventQuery) ;
			if(pEventQuery) {
				pEventQuery->Issue(D3DISSUE_END) ;
				while(S_FALSE == pEventQuery->GetData(NULL, 0, D3DGETDATA_FLUSH)) ;
				pEventQuery->Release(); // Must be released or causes a leak and reference count increment
			}
			return true;
		}
	}

	SpoutLogError("spoutDirectX9::WriteDX9surface(0x%.7X, 0x%.7X) failed", PtrToUint(surface), PtrToUint(dxTexture) );

	return false;
}
