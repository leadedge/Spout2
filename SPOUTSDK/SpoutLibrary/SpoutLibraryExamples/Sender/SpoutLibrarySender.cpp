/*
=========================================================================

                    SpoutLibrarySender.cpp

		Basic OpenGL Spout sender using SpoutLibrary

    A Windows Desktop Application project generated by Visual Studio
    and adapted for Spout sender output (https://spout.zeal.co/).

	This is an example using SpoutGL SendImage and SendTexture

	bool SendImage(const unsigned char* pixels, 
	               unsigned int width, unsigned int height,
				   GLenum glFormat, bool bInvert, GLuint HostFBO)

	bool SendTexture(GLuint TextureID, GLuint TextureTarget,
	                 unsigned int width, unsigned int height,
					 bool bInvert, GLuint HostFBO);

    This application captures the screen to a pixel buffer using Windows
	bitmap functions. The screen can be resized to demonstrate sender update.

	Search on "SPOUT" for additions.

	Compare with "SpoutLibraryExample > SpoutLibraryReceiver"
	and with the Openframeworks sender example - Examples\Windows\SenderOpenGL

	---------------------------------------------------------------------------
				 
				 Copyright(C) 2025 Lynn Jarvis.

    This program is free software : you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.If not, see < http://www.gnu.org/licenses/>.

===============================================================================
*/
#include "framework.h"
#include "SpoutLibrarySender.h"
#include "SpoutLibrary.h"

// Specify SpoutLibrary.lib for the linker
#pragma comment(lib, "libs/SpoutLibrary.lib")

//
// Notes :
//
// 1) SpoutLibrary.dll must be in the executable folder
//    It is copied to that folder by the Visual Studio project
// 2) SpoutLibrary must be built first for the same build configuration
//    Debug or Release. This copies the required file to the "Libs" folder
// 3) Code Generation property is - Multi-threaded DLL (/MD) for release or
//    Multi-threaded Debug DLL (/MDd) for debug
//    SpoutLibrary must be built with the same Code Generation property

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;                                // current instance
WCHAR szTitle[MAX_LOADSTRING];                  // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name

// SPOUT
int WindowPosLeft = 0;
int WindowPosTop = 0;
int window_width = 0;
int window_height = 0;
SPOUTLIBRARY* sender;                   // SpoutLibrary object
HWND g_hWnd = NULL;                     // Window handle
HBITMAP g_hBitmap = NULL;               // Image bitmap for window capture
unsigned int g_BitmapWidth = 0;         // Image bitmap width
unsigned int g_BitmapHeight = 0;        // Image bitmap height
unsigned char *g_pixelBuffer = nullptr; // Sending pixel buffer
GLuint g_TextureGL;                     // SendTexture example

static char g_SenderName[256]{};        // Sender name for user entry
unsigned int g_SenderWidth = 0;         // Sender width
unsigned int g_SenderHeight = 0;        // Sender height

// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
// The About dialog is replaced with SpoutMessageBox

// SPOUT
void Render();

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

	// ----------------------------------
	// SPOUT
	// Get a pointer to SpoutLibrary
	sender = GetSpout();
	if (!sender) {
		MessageBoxA(NULL, "Load Spout library failed", "Spout Library Sender", MB_ICONERROR);
		return FALSE;
	}

	// Load a bitmap from resources
	g_hBitmap = (HBITMAP)LoadImageA(GetModuleHandle(NULL), MAKEINTRESOURCEA(IDB_WINSPOUTBMP), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
	if (!g_hBitmap) {
		MessageBoxA(NULL, "Failed to load image", "Spout Library Sender", MB_OK);
		return FALSE;
	}

	// Get the size of the bitmap
	BITMAP bmpImage ={};
	GetObjectA(g_hBitmap, sizeof(BITMAP), &bmpImage);
	g_BitmapWidth = bmpImage.bmWidth;
	g_BitmapHeight = bmpImage.bmHeight;
	// ----------------------------------

    // Initialize global strings
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_LIBRARYSENDER, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow))
    {
        return FALSE;
    }

	// ----------------------------------
	// SPOUT

	// Initialize OpenGL now that the main window has been created
	if (!sender->CreateOpenGL(g_hWnd)) {
		SpoutMessageBox(NULL, "CreateOpenGL failed", "Spout Library Sender", MB_OK | MB_ICONWARNING);
		return FALSE;
	}

	//
	// Options
	//
	// Logging functions
	// Refer to the "SpoutLibrary" source code for further details.
	//
	// sender->OpenSpoutConsole(); // Empty console for debugging
	sender->EnableSpoutLog(); // Enable console logging to detect Spout warnings and errors
	// Log the Spout SDK version number e.g. "2.007.000"
	sender->SpoutLog("Spout version : %s", sender->GetSDKversion().c_str());

	//
	// Many other options are available but are not repeated in this example.
	// Refer to SpoutLibary.h for more options
	//
	
	// Create a sending buffer of inital size
	// It is resized as necessary - see WM_PAINT
	g_SenderWidth  = g_BitmapWidth;
	g_SenderHeight = g_BitmapHeight;
	unsigned int buffersize = g_SenderWidth * g_SenderHeight * 4;
	g_pixelBuffer = new unsigned char[buffersize];

	// Create an OpenGL texture for the SendTexture option
	sender->InitTexture(g_TextureGL, GL_RGBA, g_SenderWidth, g_SenderHeight);

	//
	// Give the sender a name
	//
	// If none is specified, the executable name is used
	// A global name is used for user sender name change
	// See further details in IDM_SENDER
	sprintf_s(g_SenderName, 256, "Spout Library Sender");
	sender->SetSenderName(g_SenderName);

	// Set the name in the Window caption
	SetWindowTextA(g_hWnd, sender->GetName());
	// ----------------------------------

    // Main message loop:
	MSG msg{};
	while (WM_QUIT != msg.message)
	{
		if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		Render();
	}

	// ----------------------------------
	// SPOUT

	if(g_hBitmap) 
		DeleteObject(g_hBitmap);

	if (g_pixelBuffer) 
		delete[] g_pixelBuffer;

	// Release the sender
	sender->ReleaseSender();

	// Release OpenGL resources
	sender->CloseOpenGL();
	// ----------------------------------

    return (int) msg.wParam;
}


// ----------------------------------
// SPOUT
void Render()
{
	// Trigger a re-paint to draw the bitmap
	// and refresh the sending pixel buffer - see WM_PAINT
	InvalidateRect(g_hWnd, NULL, FALSE);
	UpdateWindow(g_hWnd); // Update immediately

	// A pixel buffer and OpenGL texture are produced in WM_PAINT
	// The pixel buffer and texture are updated for window size changes

	//
	// OPTION 1) - Send image pixels
	//
	// SendImage manages sender create and re-size
	// RGBA, BGRA, RGB, BGR are supported
	// Windows screen capture pixels are BGRA
	// sender.SendImage(g_pixelBuffer, g_SenderWidth, g_SenderHeight, GL_BGRA);

	//
	// OPTION 2) - Send texture
	//
	// In this example, pixels are be loaded to the texture (see WM_PAINT)
	// In most OpenGL applications, a texture is available directly
	// See details in the Openframeworks Sender > Graphics example
	sender->SendTexture(g_TextureGL, GL_TEXTURE_2D, g_SenderWidth, g_SenderHeight, false); // No invert

	// Option - SendFbo is not available for this example
	// See details in the Openframeworks Sender > Graphics example

	//
	// Fps control
	//
	// Hold a target frame rate - e.g. 60 or 30fps.
	// Not necessary if the application already has fps control
	// but in this example, render rate can be extremely high if 
	// graphics driver "wait for vertical refresh" is disabled.
	sender->HoldFps(60);

}
// ----------------------------------


//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_LIBRARYSENDER));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
	// SPOUT - hatched background
	wcex.hbrBackground  = CreateHatchBrush(HS_DIAGCROSS, RGB(192, 192, 192));
	// wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_LIBRARYSENDER);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

	// SPOUT - Create window
	RECT rc = { 0, 0, 640, 360 }; // Desired client size
	AdjustWindowRect(&rc, WS_CAPTION | WS_SYSMENU | WS_THICKFRAME, TRUE);
	HWND hWnd = CreateWindowW(szWindowClass, szTitle,
	// SPOUT - enable resize and maximize to demonstrate sender resizing
	WS_OVERLAPPEDWINDOW,
	CW_USEDEFAULT, CW_USEDEFAULT, 
	rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd) {
      return FALSE;
   }

   // ----------------------------------
   // SPOUT
   // Centre the window on the desktop work area
   GetWindowRect(hWnd, &rc);
   RECT WorkArea;
   SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
   WindowPosLeft += ((WorkArea.right  - WorkArea.left) - (rc.right - rc.left)) / 2;
   WindowPosTop  += ((WorkArea.bottom - WorkArea.top)  - (rc.bottom - rc.top)) / 2;
   MoveWindow(hWnd, WindowPosLeft, WindowPosTop, (rc.right - rc.left), (rc.bottom - rc.top), false);
   // ----------------------------------

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   // Global window handle used in some functions
   g_hWnd = hWnd;

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Parse the menu selections:
            switch (wmId)
            {
				// ----------------------------------
				// SPOUT
				// Pop up a SpoutMessageBox edit control
				// for the user to change the sender name
				case IDM_SENDER:
				{
					std::string str = g_SenderName; // The string to return from the edit control
					if (SpoutMessageBox(hWnd, NULL, "Enter a new sender name", MB_OKCANCEL, str) == IDOK) {
						// Release the sender before changing the name
						// Another one with the new name is created when
						// SendImage or SendTexture are called again
						sender->ReleaseSender();
						// Update the sender name after releasing the sender
						strcpy_s(g_SenderName, 256, str.c_str());
						sender->SetSenderName(g_SenderName);
						// Set the window text with the new name
						SetWindowTextA(g_hWnd, g_SenderName);
					}
				}
				break;
				// ----------------------------------

            case IDM_ABOUT:
				// ----------------------------------
				// SPOUT
				// Replace the original resource dialog with SpoutMessageBox
				{
					std::string about = "         SpoutLibrary Sender example\n\n";
					about += "                'File > Sender name'\n";
					about += "    to enter a new name for the sender\n\n";
					about += "                <a href=\"http://spout.zeal.co/\">http://spout.zeal.co</a>\n";
					// Get a custom icon for the SpoutMessagBox from resources
					SpoutMessageBoxIcon(LoadIconA(GetModuleHandle(NULL), MAKEINTRESOURCEA(IDI_LIBRARYSENDER)));
					// Centre on the application window
					SpoutMessageBoxWindow(hWnd);
					SpoutMessageBox(NULL, (LPSTR)about.c_str(), "SenderWindows", MB_USERICON | MB_OK);
				}
				// ----------------------------------

                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
    case WM_PAINT:
		// ----------------------------------
		// SPOUT
        {
			if (IsIconic(hWnd))
				break;

			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(g_hWnd, &ps);

			// For this example, draw an image, capture the client area
			// and copy pixel data to the sending buffer.

			//
			// Draw the image bitmap
			//
			
			// Get the client area
			RECT rcClient;
			GetClientRect(hWnd, &rcClient);
			UINT rcWidth = (rcClient.right - rcClient.left);
			UINT rcHeight = (rcClient.bottom - rcClient.top);

			// Create a compatible memory DC and select the image bitmap into it
			HDC hdcMemDC = CreateCompatibleDC(hdc);
			SelectObject(hdcMemDC, g_hBitmap);

			// Stretch blit the image to the client area
			SetStretchBltMode(hdc, COLORONCOLOR); // Fastest method
			StretchBlt(hdc,	0, 0,
						rcWidth, rcHeight, // client size
						hdcMemDC, 0, 0,
						g_BitmapWidth, g_BitmapHeight, // image size
						SRCCOPY);

			//
			// Capture the client area for sending
			//

			// The window is re-sizable - check for client area size change
			if (rcWidth != g_SenderWidth || rcHeight != g_SenderHeight) {
				// Update the sender dimensions
				g_SenderWidth  = rcWidth;
				g_SenderHeight = rcHeight;
				// Re-size the the sending buffer to match
				if(g_pixelBuffer) delete[] g_pixelBuffer;
				unsigned int buffersize = g_SenderWidth * g_SenderHeight * 4;
				g_pixelBuffer = new unsigned char[buffersize];
				// Update the example texture as well
				sender->InitTexture(g_TextureGL, GL_RGBA, g_SenderWidth, g_SenderHeight);
			}
			// The sender is now the same size as the client area

			// Create a compatible bitmap sized to the client area
			HBITMAP hBitmap = CreateCompatibleBitmap(hdcMemDC, rcWidth, rcHeight);

			// Select the bitmap into the memory DC
			HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdcMemDC, hBitmap);

			// Blit the client screen into it
			BitBlt(hdcMemDC, 0, 0,
				   rcClient.right - rcClient.left,
				   rcClient.bottom - rcClient.top,
				   hdc, 0, 0, SRCCOPY);

			// Copy to our sending buffer
			GetBitmapBits(hBitmap, rcWidth*rcHeight*4, (LPVOID)g_pixelBuffer);

			// Windows screen capture produces alpha 0 for the whole image.
			// Some applications display the received image as black,
			// so alpha of all the pixels should be converted to 255. 
			// See also : http://www.winprog.org/tutorial/transparency.html
			// The following function consumes approximately 1.5 msec at 1920x1080
			sender->ClearAlpha(g_pixelBuffer, g_SenderWidth, g_SenderHeight, 255);

			// Fill the texture with the pixels for this example 
			// The format of the pixel data is BGRA
			glBindTexture(GL_TEXTURE_2D, g_TextureGL);
			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, g_SenderWidth, g_SenderHeight, GL_BGRA, GL_UNSIGNED_BYTE, (GLvoid*)g_pixelBuffer);
			glBindTexture(GL_TEXTURE_2D, 0);

			// Clean up
			SelectObject(hdcMemDC, hOldBitmap);
			DeleteObject(hBitmap);
			DeleteDC(hdcMemDC);
		
			EndPaint(hWnd, &ps);
        }
		// ----------------------------------
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
